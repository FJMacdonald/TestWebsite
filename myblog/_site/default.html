<!-- Set Up Your Website: Create the structure of your website using HTML, CSS, and JavaScript. 
You'll need an HTML file to create the user interface, a CSS file for styling,
 and a JavaScript file to handle the file upload and D3.js visualization.

Create the User Interface: 
Design the user interface where users can upload their CSV files. You can use HTML form elements 
and styling to create an intuitive and user-friendly interface.

Implement File Upload Functionality: Write JavaScript code to handle the file upload process. 
Use the File API to allow users to select and upload CSV files from their local device. 
You'll also need to handle the file upload event and read the contents of the uploaded CSV file.

Parse and Process the CSV Data: Once the CSV file is uploaded, parse its contents using JavaScript. 
You can use libraries like Papa Parse to parse CSV data easily. Process the data as needed to prepare 
it for visualization with D3.js.

Visualize the Data with D3.js: Use D3.js to create custom visualizations based on the data from the CSV file. 
You can create various types of charts, graphs, or other visualizations to present the data in a special way 
according to your requirements.

Test Your Website: Before deploying your website, thoroughly test it to ensure that the file upload and
visualization functionalities work correctly across different browsers and devices.
Deploy Your Website: Once you're satisfied with your website, deploy it to your chosen hosting platform. 
Follow the instructions provided by the hosting platform to deploy your website for free.

Share Your Website: Share the URL of your website with others so they can upload their CSV files and explore
 the visualizations you've created with D3.js.
By following these steps, you can create a free website that allows users to upload CSV files
 and presents the data in a special way using D3.js for visualization. -->


<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CSV File Upload</title>
</head>

<body>
    <!-- Initialize the ffile select button -->
    <input type="file" id="csvFileInput" accept=".csv">
    <div id="csvData"></div>

    <!-- Initialize the reset button -->
    <button id="resetButton" style="margin-bottom: 10px">Reset</button>

    <!-- Create a div where the graph will take place -->
    <div>
        <div id="chart_title"></div>
        <div id="chart"></div>
    </div>

    <script src="https://d3js.org/d3-color.v1.min.js"> </script>
    <script src="https://d3js.org/d3-interpolate.v1.min.js"> </script>
    <script src="https://d3js.org/d3-scale-chromatic.v1.min.js"> </script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
        const athletesArray = [];
        const leadersArray = [];
        var max_time_lag = 0;
        var title = "";

        // Add event listener for file input change
        const fileInput = document.getElementById('csvFileInput');
        fileInput.addEventListener('change', handleFileUpload);

        // Add event listener for reset chart button
        const reset = document.getElementById('resetButton');
        reset.addEventListener('change', drawChart(athletesArray, leadersArray));
        
        // Function to handle file upload
        function handleFileUpload(event) {
            const file = event.target.files[0]; // Get the uploaded file
            title = file["name"].replace(/Results for |.csv/g, "");
            // Get the div element by its ID
            let chartTitleDiv = document.getElementById("chart_title");

            // Update the inner HTML of the div with the new title
            chartTitleDiv.innerHTML = title;

            // Create a new FileReader object
            const reader = new FileReader(); 
            // Define the onload event handler for the FileReader
            reader.onload = function (e) {
                console.log("on load");
                const csvData = e.target.result; // Get the CSV data
                //   displayCSVData(csvData); // Call function to display CSV data
                processData(csvData, athletesArray, leadersArray);
                console.log("leadersArray", leadersArray);
                console.log("athletesArray", athletesArray);
                drawChart(athletesArray, leadersArray);
            };

            // Read the uploaded file as text
            reader.readAsText(file);
        }

        // Function to display CSV data
        function displayCSVData(csvData) {
            const csvDataDiv = document.getElementById('csvData'); // Get the div element
            csvDataDiv.textContent = csvData; // Display the CSV data in the div
        }

        // Function converts time String formated as hr:min:sec to an int of seconds
        function convertToSeconds(timeString) {
            // Split the time string into hours, minutes, and seconds
            const [hours, minutes, seconds] = timeString.split(':').map(Number);
            // Convert hours, minutes, and seconds to seconds
            const totalSeconds = hours * 3600 + minutes * 60 + seconds;
            return totalSeconds;
        }
        
        // Function to process csv data into arrays used by drawChart
        function processData(csvData, athletesArray, leadersArray) {
            console.log("processData");
            const lines = csvData.split('\n');
            const headers = lines[0].split(',');

            const results = [];
            //process csv file into a results array
            for (let i = 1; i < lines.length; i++) {
                const obj = {};
                const currentline = lines[i].split(',');
                headers.forEach((header, index) => {
                    obj[header] = currentline[index];
                });
                results.push(obj);
            }


            // Convert time strings to seconds and store each stage of the race
            var leadSwim = 0;
            var leadT1 = 0;
            var leadBike = 0;
            var leadT2 = 0;
            var leadRun = 0;
            //  console.log("results length", results.length)
            for (let i = 0; i < results.length; i++) {
                //       console.log("res", i, results[i]);
                var name = results[i]["Athlete First Name"] + " " + results[i]["Athlete Last Name"];
                //   if (results[i].length > 0 ) {

                var swim = convertToSeconds(results[i]["Swim"]);
                var t1 = convertToSeconds(results[i]["T1"]);
                if (t1 != 0) {
                    t1 += swim;
                }
                var bike = convertToSeconds(results[i]["Bike"]);
                if (bike != 0) {
                    bike += t1;
                }
                var t2 = convertToSeconds(results[i]["T2"]);
                if (t2 != 0) {
                    t2 += bike;
                }
                var run = convertToSeconds(results[i]["Run"]);
                if (run != 0) {
                    run += t2;
                }

                //  Process the results to find the race leader at every stage
                //        console.log(name, swim, t1, bike, t2, run);
                if (i == 0) {
                    leadSwim = swim;
                    leadT1 = t1;
                    leadBike = bike;
                    leadT2 = t2;
                    leadRun = run;
                    console.log(swim, t1, bike, t2, run);
                    console.log("lead swimmer: " + name);
                } else {
                    if (swim != 0 && swim < leadSwim) {
                        leadSwim = swim;
                        console.log("lead swimmer: " + name);
                    }
                    if (t1 != 0 && t1 < leadT1) {
                        leadT1 = t1;
                        console.log("lead t1: " + name);
                    }
                    if (bike != 0 && bike < leadBike) {
                        leadBike = bike;
                        console.log("lead biker: " + name);
                    }
                    if (t2 != 0 && t2 < leadT2) {
                        leadT2 = t2;
                        console.log("lead t2: " + name);
                    }
                    if (run != 0 && run < leadRun) {
                        leadRun = run;
                        console.log("lead runner: " + name);
                    }
                }
                athletesArray.push({
                    athleteName: name,
                    swim: swim,
                    t1: t1,
                    bike: bike,
                    t2: t2,
                    run: run,
                    position: results[i]["Position"],
                    status: results[i]["Status"],
                });
                //        console.log(name + " pushed")
                leadersArray[0] = leadSwim;
                leadersArray[1] = leadT1;
                leadersArray[2] = leadBike;
                leadersArray[3] = leadT2;
                leadersArray[4] = leadRun;

                //       console.log("leadersArray", leadersArray);
            }

        }

        // Draws the chart
        function drawChart(athletesArray, leadersArray) {
            if (athletesArray.length == 0) {
                return
            }
            const colorPalette = [
                "#FF5733", // Red
                "#0074D9", // Cerulean
                "#FF851B", // Orange
                "#39CCCC", // Cyan
                "#FF4136", // Scarlet
                "#2ECC40", // Green
                "#FFDC00", // Yellow
                "#FF6B81", // Blush
                "#FFD700", // Gold
                "#7FDBFF", // Azure
                "#B10DC9", // Electric Purple
                "#01FF70", // Lime
                "#AAAAAA", // Grey
                "#F012BE", // Magenta
                "#3D9970", // Emerald
                "#111111", // Black
                "#F012BE", // Magenta
                "#01FF70", // Lime
                "#B10DC9", // Electric Purple
                "#FF6B81", // Blush
                "#0074D9", // Cerulean
                "#FFD700", // Gold
                "#AAAAAA", // Grey
                "#7FDBFF", // Azure
                "#2ECC40", // Green
                "#FF4136", // Scarlet
                "#FFDC00", // Yellow
                "#FF851B", // Orange
                "#0074D9", // Cerulean
                "#FF6B81", // Blush
                "#FFDC00", // Yellow
                "#3D9970", // Emerald
                "#FF851B", // Orange
                "#F012BE", // Magenta
                "#B10DC9", // Electric Purple
                "#2ECC40", // Green
                "#01FF70", // Lime
                "#AAAAAA", // Grey
                "#7FDBFF", // Azure
                "#FF4136", // Scarlet
                "#111111", // Black
                "#FFD700", // Gold
                "#0074D9", // Cerulean
                "#FF5733", // Red
                "#3D9970", // Emerald
                "#FF6B81", // Blush
                "#B10DC9", // Electric Purple
                "#FF851B", // Orange
                "#01FF70", // Lime
                "#FF4136", // Scarlet
                "#FFDC00", // Yellow
                "#0074D9", // Cerulean
                "#FFD700", // Gold
                "#AAAAAA", // Grey
                "#2ECC40", // Green
                "#7FDBFF", // Azure
                "#F012BE", // Magenta
                "#111111", // Black
                "#B10DC9", // Electric Purple
                "#01FF70", // Lime
                "#FF6B81", // Blush
                "#FFDC00", // Yellow
                "#FF4136", // Scarlet
                "#3D9970", // Emerald
                "#0074D9", // Cerulean
                "#FF851B", // Orange
                "#AAAAAA", // Grey
                "#FF5733"  // Red
            ];
// ].map(color => darken(color));

//             function darken(color) {
//                 const factor = 0.85; // Adjust this factor to control darkness
//                 return '#' + color.slice(1).match(/.{2}/g).map(channel => Math.floor(parseInt(channel, 16) * factor).toString(16).padStart(2, '0')).join('');
//             }



            // Add a click event listener to the reset button
            document.getElementById("resetButton").addEventListener("click", resetChart);

            // Function to reset the chart
            function resetChart() {
                console.log("reset chart");
                // Reset the y-axis scale to its original domain
                yScale.domain([-max_time_lag, 0]);

                // Update the y-axis
                svg.select(".y.axis").call(yAxis);

                // Update the lines and circles based on the original yScale
                updateLinesAndCircles();
                //Update Y-axis
                updateYAxis();

                // Reset the brush to its initial position
                svg.select(".brush").call(yBrush.move, null);
            }



            const duration = 300; //To calibrate all races to proportions of swim=10, t=2, bike=30, run=20
            const raceLength = 70;

            resultsArray = [];

            //   console.log("athletesArray length", athletesArray.length);

            for (let i = 0; i < athletesArray.length; i++) {
                console.log("athletesArray[i]", i, athletesArray[i]);
                const runDiff = athletesArray[i].run - leadersArray[4];
                //    console.log("runDiff", runDiff);
                if (runDiff > max_time_lag) {
                    max_time_lag = runDiff;
                }
                 //check for lapped out or dnf
                if (athletesArray[i].status != ""){
                    console.log(athletesArray[i])
                    if (athletesArray[i].swim < 1.0) {
                        athletesArray[i].swim = 0;
                    }
                    else if (athletesArray[i].t1 < 1.0) {
                        athletesArray[i].t1 = 99999;
                        athletesArray[i].bike = 99999;
                        athletesArray[i].t2 = 99999;
                        athletesArray[i].run = 99999;
                    }
                    else if (athletesArray[i].bike < 1.0) {
                        athletesArray[i].bike = 99999;
                        athletesArray[i].t2 = 99999;
                        athletesArray[i].run = 99999;
                    }
                    else if (athletesArray[i].t2 < 1.0) {
                        athletesArray[i].t2 = 99999;
                        athletesArray[i].run = 99999;
                    }                    
                    else if (athletesArray[i].run < 1.0) {
                        athletesArray[i].run = 99999;
                    }              
                }  
                var values = [];              
                if (athletesArray[i].status == "DNS"){
                    values = [{ "x": 0, "y": 0, "diff": "" },
                    { "x": 0, "y": 0, "diff": "" }, { "x": 0, "y": 0, "diff": "" },
                    { "x": 0, "y": 0, "diff": "" }, { "x": 0, "y": 0, "diff": ""}];
                } else {
                    values = [{ "x": 0, "y": 0, "diff": convertToMinutes(0) },
                    { "x": 10, "y": leadersArray[0] - athletesArray[i].swim, "diff": convertToMinutes(athletesArray[i].swim - leadersArray[0]) },
                    { "x": 12, "y": leadersArray[1] - athletesArray[i].t1, "diff": convertToMinutes(athletesArray[i].t1 - leadersArray[1]) },
                    { "x": 42, "y": leadersArray[2] - athletesArray[i].bike, "diff": convertToMinutes(athletesArray[i].bike - leadersArray[2]) },
                    { "x": 44, "y": leadersArray[3] - athletesArray[i].t2, "diff": convertToMinutes(athletesArray[i].t2 - leadersArray[3]) },
                    { "x": 64, "y": leadersArray[4] - athletesArray[i].run, "diff": convertToMinutes(athletesArray[i].run - leadersArray[4]) }];
                }
                resultsArray.push({
                    athleteName: athletesArray[i].athleteName,
                    position: athletesArray[i].position,
                    status: athletesArray[i].status,
                    values: values,
                });
            }
            console.log("**********************max time lag: ", max_time_lag);

            //This function takes an input time in seconds, calculates the minutes and remaining 
            //seconds, and formats them as "minutes:seconds". It also ensures that single-digit 
            //seconds are padded with a leading zero.
            function convertToMinutes(timeInSeconds) {
                const minutes = Math.floor(timeInSeconds / 60);
                const seconds = Math.floor(timeInSeconds % 60);
                const formattedTime = `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
                return formattedTime;
            }

            // Define the size and spacing of the rectangles
            const size = 25;

            //rectangles in the legend (athletes + teams)
            nRects = resultsArray.length
            const clientWidth = d3.select("#chart").node().getBoundingClientRect().width;
            const nColumns = Math.trunc(clientWidth / 120);
            const bottom = Math.ceil(nRects / nColumns) * size * 1.2 + 70;


            // set the dimensions and margins of the graph
            var margin = { top: 40, right: 10, bottom: bottom, left: 50 },
                width = clientWidth - margin.left - margin.right,
                height = 500
            // append the svg object to the body of the page
            var svg = d3.select("#chart")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform",
                    "translate(" + margin.left + "," + margin.top + ")");

            // Create a rectangle for the frame
            var frame = svg.append("rect")
                .attr("x", 0)
                .attr("y", 0)
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .attr("rx", 10)
                .attr("ry", 10)
                .attr("stroke", "gray")
                .attr("opacity", 0.6)
                .attr("stroke-width", 2)
                .attr("fill", "transparent")
                .attr("transform",
                    "translate(-" + margin.left + ",-" + margin.top + ")");


            var xScale = d3.scaleLinear()
                .domain([0, raceLength]) //assuming a 90min race
                .range([0, width]); //leaving space for ledgend

            // Extract y-coordinates from data
            // const yValues = athletesArray.flatMap(athlete => athlete.values.flat());//.map(point => point.y));

            // Define the initial yScale
            const yScale = d3.scaleLinear()
                .domain([-max_time_lag, 0])
                .range([height, 0]);

            // Define the initial yAxis
            const yAxis = d3.axisLeft(yScale).ticks(0);

            // Append the yAxis to the svg
            svg.append("g")
                .attr("class", "y axis")
                .call(yAxis)
                .append('text')
                .attr("y", -30)
                .attr("x", -10)
                .style("font-size", "13px")
                .attr("transform", "rotate(-90)")
                .attr("fill", "#000");



            // Add brushing for y-axis
            var yBrush = d3.brushY()
                .extent([[0, 0], [width, height]])
                .on("end", yBrushed);

            // Create the area variable: where both the area and the brush take place
            var area = svg.append('g')
                .attr("class", "brush")
                .call(yBrush);

            function yBrushed(event) {
                if (!event.selection) return; // Ignore empty selections

                // Get the brushed extent
                var yBrushExtent = event.selection.map(yScale.invert);

                // Update yScale domain
                yScale.domain(yBrushExtent);

                // Update yScale domain if the minimum is greater than the maximum
                if (yBrushExtent[0] > yBrushExtent[1]) {
                    yScale.domain([yBrushExtent[1], yBrushExtent[0]]);
                } else {
                    yScale.domain(yBrushExtent);
                }

                // Update y-axis with meaningful ticks
                updateYAxis();

                // Update the lines and circles based on the new yScale
                updateLinesAndCircles();

                // Reset the brush to its initial position
                svg.select(".brush").call(yBrush.move, null);

            }
            // Handle touch events
            svg.on("touchstart", yBrushed)
                .on("touchmove", yBrushed)
                .on("touchend", yBrushed);


            function updateLinesAndCircles() {

                // Update lines
                svg.selectAll(".line")
                    .attr("d", d3.line()
                        .x(d => xScale(d.x))
                        .y(d => yScale(d.y)));

                // Update circles
                svg.selectAll(".athlete-circle")
                    .attr("cy", d => yScale(d.y));

                // Update labels
                svg.selectAll(".line-text")
                    .attr("y", d => yScale(d.y));


            }

            // Function to update the y-axis based on the current yScale
            function updateYAxis() {

                // Calculate the range of the yScale
                const yRange = yScale.domain();

                // Calculate the difference between the max and min values
                const yRangeDiff = yRange[1] - yRange[0];

                // Determine the number of ticks based on the yRangeDiff
                let numberOfTicks;

                if (yRangeDiff <= 60) {
                    // If the range is less than or equal to 60 seconds, show ticks every 10 seconds
                    numberOfTicks = yRangeDiff / 10;
                } else if (yRangeDiff <= 600) {
                    // If the range is less than or equal to 600 seconds (10 minutes), show ticks every minute
                    numberOfTicks = yRangeDiff / 60;
                } else if (yRangeDiff >= 1800) {
                    // If the range is greater than (30 minutes), show ticks every 5 minutes
                    numberOfTicks = Math.floor(yRangeDiff / 300);
                } else {
                    // Otherwise, show ticks every 2 minutes
                    numberOfTicks = yRangeDiff / 120;
                }
                svg.select(".y.axis text").remove();
                // Define the y-axis with the calculated number of ticks and custom tick format
                const yAxis = d3.axisLeft(yScale).ticks(numberOfTicks).tickFormat(d => {
                    if (d < -90) {
                        const mins = -Math.floor(d / 60);
                        const secs = -d % 60
                        return mins + ":" + (secs < 10 ? '0' + secs : secs);
                    } else {
                        return -d; // For values under or equal to 90 seconds, use the default format
                    }
                });


                // Update the y-axis
                svg.select(".y.axis").call(yAxis);
                // Add y-axis gridlines
                svg.selectAll(".y-gridline").remove(); // Remove existing gridlines

                svg.selectAll(".y-gridline")
                    .data(yScale.ticks(numberOfTicks))
                    .enter()
                    .append("line")
                    .attr("class", "y-gridline")
                    .attr("x1", 0)
                    .attr("x2", width)
                    .attr("y1", d => yScale(d))
                    .attr("y2", d => yScale(d))
                    .style("stroke", "#ddd")  // Adjust the color as needed
                    .style("stroke-dasharray", "3,3");  // Add dashes for a dashed appearance

                // Update the y-axis label dynamically
                const yDomain = yScale.domain();
                const isSeconds = yDomain[0] >= 0 && yDomain[1] <= 90; // Assuming 90 seconds threshold, adjust as needed

            }




            updateChart(10 * 360);
            updateYAxis();


            function updateChart(max_time_lag) {


                // Create a group for all athletes
                const athleteGroup = svg.append("g")
                    .attr("class", "athlete-group");


                //  const yScale = d3.scaleLinear()
                //      .domain([-max_time_lag, 0])
                //      .range([height, 0]);
                // console.log("yScale", yScale* 1708);
                // const yScale2 = d3.scaleLinear()
                //      .domain([max_time_lag, 0])
                //      .range([height, 0]);
                // console.log("yScale2", yScale2* 1708);
                var lineOpacity = "0.5";
                var lineStroke = "1.0";

                var circleRadius = 3;
                const circleRadiusHover = 6;


                var legendIndex = 0;

                resultsArray.forEach((athlete, athleteIndex) => {
                    x = legendIndex % nColumns * (clientWidth / nColumns) - 20;
                    y = height + Math.floor(legendIndex / nColumns) * 30 + 50;
                    athleteGroup.append("rect")
                        .attr("x", x)
                        .attr("y", y)
                        .attr("width", size)
                        .attr("height", size)
                        .style("stroke", "Black")
                        .style("stroke-width", lineStroke)
                        .style("fill", "white");
                    // Athletes - legend for each athlete
                    athleteGroup.append("rect")
                        .attr("class", "athlete-ledgend")
                        .attr("x", x)
                        .attr("y", y)
                        .attr("width", size)
                        .attr("height", size)
                        .attr("fill", colorPalette[athleteIndex]) // Assign colors based on athlete index within the team
                        .style('opacity', lineOpacity)
                        .style("stroke", "Black")
                        .style("stroke-width", lineStroke)
                        .on("click", function () {
                            //Check if the rect is selected 
                            var athleteRect = d3.select(this);
                            var opacity = athleteRect.style("opacity");
                            if (opacity == 0.5) {
                                lineOpacity = 1.0
                                lineStroke = 3.0
                                circleRadius = 3
                            } else if (opacity == 1.0) {
                                lineOpacity = 0.0
                                lineStroke = 1.0
                                circleRadius = 0
                            } else {
                                lineOpacity = 0.5
                                lineStroke = 1.0
                                circleRadius = 3
                            }
                            athleteRect.style("opacity", lineOpacity);


                            const athleteLine = svg.selectAll(".line").filter((d, i) => i === athleteIndex);
                            athleteLine.style("opacity", lineOpacity);
                            athleteLine.style("stroke-width", lineStroke);
                            
                            const athletetext = svg.selectAll(".line-text").filter((d, i) => i === athleteIndex);

                            console.log("athlete text", athletetext);
                            console.log("athlete line", athleteLine);
                            console.log("athlete index", athleteIndex);
                            if (lineOpacity == 1.0) {
                                athletetext.style("visibility", "visible");
                            } else {
                                athletetext.style("visibility", "hidden");
                            }

                            const athleteCircles = Array.from(svg.selectAll(".athlete-circle").nodes());
                            const circlesForAthlete = athleteCircles.filter(circle => d3.select(circle).attr("athlete") === athlete);
                            circlesForAthlete.forEach(circle => {
                                d3.select(circle)
                                    .style("opacity", lineOpacity)
                                    .attr("r", circleRadius);
                            });

                        });
                    //Add athlete first name next to rect
                    athleteGroup.append("text")
                        .attr("x", x + 1.2 * size)
                        .attr("y", y + 0.4 * size)
                        .attr("fill", colorPalette[athleteIndex])
                        .text(athlete.athleteName.split(' ')[0])
                        .attr("text-anchor", "left")
                        .style("font-size", "12px")
                    //Add last name next to rect
                    athleteGroup.append("text")
                        .attr("x", x + 1.2 * size)
                        .attr("y", y + 0.9 * size)
                        .attr("fill", colorPalette[athleteIndex])
                        .text(athlete.athleteName.split(' ')[1] + " " + athlete.status)
                        .attr("text-anchor", "left")
                        .style("font-size", "12px")

                    //increment legendIndex
                    legendIndex += 1;
                    
                    //Draw chart items (path, circles, name text)
                    athleteGroup.append("path")
                        .datum(athlete.values)
                        .attr("class", "line")
                        .attr("fill", "none")
                        .attr("stroke", colorPalette[athleteIndex])
                        .attr("stroke-width", lineStroke)
                        .attr("d", d3.line()
                            .x(d => { return xScale(d.x); })
                            .y(d => { return yScale(d.y); }))
                        .attr("fill", "none")
                        .style('opacity', lineOpacity)
                        .attr("clip-path", "url(#clip)")
                        .on("mouseover", function (d, i) {
                            const [mouseX, mouseY] = d3.pointer(event, this);
                            svg.append("text")
                                .attr("class", "title-text")
                                .style("fill", colorPalette[athleteIndex])
                                .text(athlete.athleteName)
                                .attr("text-anchor", "left")
                                .attr("x", mouseX)
                                .attr("y", mouseY)
                                .style("font-size", "12px")
                        })
                        .on("mouseout", function (d) {
                            svg.select(".title-text").remove();
                        });

 
                    athleteGroup.selectAll(".text")
                            .data(athlete.values)
                            .enter()
                            .append("text")
                            .attr("class", "line-text")
                            .attr("x", xScale(raceLength - 5))
                            .attr("y", d => yScale(d.y))
                            .attr("fill", colorPalette[athleteIndex])
                            .text(athlete.athleteName.split(' ')[0] )
                          //  .style("visibility", "hidden")
                            .attr("text-anchor", "left")
                            .style("font-size", "10px");
                            
                   athleteGroup.selectAll(".circle")
                        .data(athlete.values)
                        .enter()
                        .append("circle")
                        .attr("r", circleRadius)
                        .style('opacity', lineOpacity)
                        .attr("fill", colorPalette[athleteIndex])
                        .attr("class", "athlete-circle")
                        .attr("athlete", athlete.athleteName)
                        // .attr("team", team.team)
                        .attr("cy", d => yScale(d.y))
                        .attr("cx", d => xScale(d.x))
                        .attr("clip-path", "url(#clip)")
                        .on("click", function (d, i) {
                            d3.select(this)
                                .transition()
                                .duration(duration)
                                .attr("r", circleRadiusHover)
                                .style("cursor", "pointer");
                            svg.append("text")
                                .attr("class", "text")
                                .text(i.diff)
                                .attr("x", xScale(i.x) + 5)
                                .attr("y", yScale(i.y) - 10);
                        })
                        .on("mouseout", function (d) {
                            d3.select(this)
                                .transition()
                                .duration(duration)
                                .attr("r", circleRadius)
                                .style("cursor", "none")
                            svg
                                .selectAll(".text").remove();
                        });

                            

                });

                console.log("clip");
                // Define clipping path for lines
                svg.append("defs").append("clipPath")
                    .attr("id", "clip")
                    .append("rect")
                    .attr("width", width)
                    .attr("height", height);


                svg.append("defs").append("clipPath")
                    .attr("id", "clip-labels")
                    .append("rect")
                    .attr("width", width)
                    .attr("height", height)
                    .attr("y", -10);


                // Add Axis into SVG 
                var xAxis = d3.axisTop(xScale).ticks(0);
                //            var yAxis = d3.axisLeft(yScale).ticks(0);


                svg.append("g")
                    .attr("class", "x axis")
                    .call(xAxis);


                svg.append("g")
                    .attr("class", "y axis")
                    .call(yAxis)
                    .append('text')
                    .attr("y", -36)
                    .attr("x", -10)
                    .style("font-size", "14px")
                    .attr("transform", "rotate(-90)")
                    .attr("fill", "#000")
                    .text("Time Behind Leader");



                // Call the function to draw gridlines
                drawVerticalGridlines(athleteGroup, 10);
                drawVerticalGridlines(athleteGroup, 12);
                drawVerticalGridlines(athleteGroup, 42);
                drawVerticalGridlines(athleteGroup, 44);
                // Function to draw vertical gridlines
                function drawVerticalGridlines(selection, x) {
                    selection
                        .attr("class", "gridline")
                        .append("line")
                        .attr('x1', xScale(x))
                        .attr('y1', -10)
                        .attr('x2', xScale(x))
                        .attr('y2', yScale(-height - 250))
                        .style('stroke', 'gray')
                        .style('opacity', 0.5)
                        .style("stroke-dasharray", ("3, 3"))
                        .style("stroke-width", 0.5);
                }




                //function to annotate chrt 
                function annotateChart(selection, x, y, text) {
                    selection
                        .append('text')
                        .attr('x', xScale(x))
                        .attr('y', y)
                        .text(text)
                        .style('font-size', '14px')
                        .style('fill', 'black'); // Customize the text styling as needed
                }

                // annotate with swim, t1, bike, t2, run
                annotateChart(athleteGroup, 1, -10, 'Swim');
                annotateChart(athleteGroup, 10, -10, 'T1');
                annotateChart(athleteGroup, 24, -10, 'Bike');
                annotateChart(athleteGroup, 42, -10, 'T2');
                annotateChart(athleteGroup, 52, -10, 'Run');

            }
        }
    </script>
</body>

</html>